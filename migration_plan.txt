ðŸ”„ Step-by-Step Port Plan
Step 1 â€” Core Primitives

Translate Vector2Int, PlayerColor, Move into TS classes/interfaces.

Ensure immutability via readonly props and pure constructors.

Step 2 â€” Event System

Define GameEvent as an abstract base class in TS.

Implement event types (MoveEvent, CaptureEvent, etc.).

Define EventSequence with continuation/abort policies.

Define IInterceptor<T extends GameEvent> with generic intercept method.

Step 3 â€” Engine Core

Port GameEngine, EventPipeline, ProcessMove, Simulation, and Turns.

Replace C# reflection for interceptor discovery with manual registration or decorator metadata.

Step 4 â€” State Management

Implement GameState as an immutable object.

Add helper methods for cloning, simulating, and evaluating.

Step 5 â€” Board System

Port IBoard and Board.

Ensure deep cloning support for pieces/tiles.

Step 6 â€” Piece System

Implement IPiece, PieceBase.

Implement standard pieces (Pawn, Rook, etc.) in TS.

Port MovementHelper.

Port decorators as higher-order wrappers implementing IInterceptor.

Step 7 â€” Tile System

Implement ITile, BaseTile, and custom tiles (Slippery, Guardian, etc.).

Step 8 â€” Rules & Controllers

Implement IRuleSet, StandardChessRuleSet.

Implement IPlayerController, HumanController, GreedyAIController.

Step 9 â€” Game Modes

Port IGameMode, StandardChessMode, and examples like ExplodingChessMode.

Step 10 â€” Integration with Electron

Expose engine API (start game, run turn, get history).

Hook UI into engine.OnEventPublished for React state updates.

Ensure renderer process can interact cleanly (engine runs purely in main/worker context).