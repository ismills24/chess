ğŸ¯ NEW TARGET ARCHITECTURE â€” FULL SUMMARY

This architecture has four layers:

Catalog â€” defines what content exists

GameManager â€” orchestrates the roguelike run

ChessManager â€” manages a single chess encounter

ChessEngine â€” the pure rules engine (stateless, effect-driven)

Plus, the Renderer, which consumes the outputs.

Each layer has strict responsibilities and boundaries.

ğŸŸ© 1. Catalog
Purpose:

Owns all game content, but no logic about how a game runs.

Responsibilities

Defines all:

piece types

tile types

decorators

abilities/listeners

rulesets

AI types

Provides constructors for:

ActorSnapshot

TileSnapshot

Ability/Listener instances

RuleSet implementations

Provides metadata for the renderer:

animations

3D models

visual effects

sound mappings

Constraints

Must follow the interfaces defined by ChessEngine:

Listener

Effect

RuleSet

ActorSnapshot

TileSnapshot

Must not depend on ChessManager or GameManager.

Analogy:

â€œContent plugin libraryâ€ â€” your entire chess roguelike lives here.

ğŸŸ§ 2. GameManager (Roguelike Runtime)
Purpose:

Owns a player's entire run â€” the roguelike meta-game.

Responsibilities

Manages:

player inventory

relics / items

run RNG seed

gold

shop options

map layout (fight â†’ shop â†’ event â†’ boss)

Chooses:

the next encounter type

which AI to use for enemies

which rule set (classic, last-piece-standing, chaos, etc.)

Instantiates a new ChessManager whenever a fight starts.

Saves and loads run state.

Reads from Catalog to construct:

allowed pieces

allowed tiles

abilities in this run

possible upgrades

Constraints

Never touches ChessEngine directly.

Only interacts through ChessManager.

Analogy:

â€œSlay the Spireâ€™s RunManager, Map, and Relic system.â€
It orchestrates everything around chess, not the chess match itself.

ğŸŸ¨ 3. ChessManager (Single Match Orchestrator)
Purpose:

Owns a single chess match, from start to finish.

Responsibilities

Maintains:

canonical list of GameStates

history (for undo, replay, animation)

turn counter

Provides:

getStateHistory()

undoLastMove()

playHumanTurn(move)

playAITurn(ai)

getLegalMoves()

Applies a player or AI move by delegating to ChessEngine.resolveMove.

Handles encounter-specific things:

â€œBoss phase 2 starts when HP < 50â€

â€œSpawn reinforcements on turn 10â€

â€œExtra abilities unlocked based on player relicsâ€

Constraints

Does not know how abilities work internally.

Does not own piece types.

Cannot modify state except via ChessEngine-created GameStates.

Analogy:

â€œThe referee + record keeper.â€
ChessManager is the match state machine around the engine.

ğŸŸ¦ 4. ChessEngine (Pure Logic Kernel)
Purpose:

A stateless, content-agnostic, deterministic simulation engine.

Responsibilities

Defines the vocabulary:

Effect / EffectType

GameState shape

ActorSnapshot shape

TileSnapshot shape

Listener interface

RuleSet interface

BoardSnapshot geometry

Implements:

resolveMove(gameState, move, config)

getLegalMoves(gameState, activePlayer, ruleset)

Provides the Listener Queue pipeline:

For each effect:

call all onBeforeEffect listeners

apply effect â†’ produce new immutable GameState

call all onAfterEffect listeners

enqueue any new effects

Enforces:

move legality

turn invariants

core semantics of effects:

movement

capture

death

tile change

stat modifications

Constraints

Does not know specific piece types (Pawn, ExplodingRook).

Does not own movement logic â€” RuleSet handles that.

Does not know specific tiles (SlipperyTile).

Does not store state.

Does not maintain history.

Analogy:

â€œThe physics engine of the chess world.â€
It defines what a MovePieceEffect means, but not what a CannonBishop is.

ğŸŸ¥ 5. Renderer (Frontend Layer)
Purpose:

Pure presentation / UI layer.

Responsibilities

Renders:

GameManager scenes (shop, map, fight, etc.)

Chess board (3D board, piece animations)

Reacts to:

state changes

resolved effect log

Provides:

user interaction

click â†’ move input

inventory UI

visual decisions (VFX based on Catalog metadata)

Constraints

No game logic.

No move legality logic.

No AI.

ğŸ§± How data flows between layers
GameManager â†’ ChessManager

â€œStart a match with this setup and these rulesets/pieces.â€

ChessManager â†’ ChessEngine

â€œResolve this move in this GameState.â€

ChessEngine â†’ ChessManager

â€œHere is your new GameState + event log.â€

ChessManager â†’ Renderer

â€œRender this board state + events.â€

Renderer â†’ ChessManager

â€œPlayer clicked here â†’ produce a Move.â€

ğŸ”¥ One-Line Summary for Each Component
Catalog

Defines content (pieces, tiles, abilities, rulesets) that conform to ChessEngineâ€™s interfaces.

GameManager

Owns the entire roguelike run; chooses encounters, inventories, upgrades, AI, shop, bosses.

ChessManager

Owns a single chess match; manages history, turns, and integrates ChessEngine into the run.

ChessEngine

Pure rules kernel; stateless; resolves moves into effects using the listener queue model.

Renderer

Shows everything; no logic.