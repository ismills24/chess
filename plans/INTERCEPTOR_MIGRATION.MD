ğŸŸ¥ Old Architecture: Interceptor Pipeline (current engine)

Model:

EventSequence â†’ Interceptors (recursive, state-frozen) â†’ CanonicalEvents â†’ Apply all at end

Core properties

ğŸ”’ State is frozen during the entire event pipeline.

ğŸ” Interceptors recursively emit new EventSequences.

ğŸ§® Complexity grows non-linearly in cascading interactions.

ğŸ§¹ Many events are generated that become invalid once state actually updates.

ğŸ”„ Undo is easy (single final state applied).

ğŸ§© Decorators/tiles implement intercept() which:

can replace/abort/extend events

but must work with stale references

cannot react to incremental state changes

Main weaknesses

âš ï¸ Interceptors see stale state
(state is not updated until the whole pipeline finishes).

âš ï¸ Recursion causes event explosion
especially with chain reactions (exploding pieces).

âš ï¸ Invalid events accumulate
(events emitted for actors already destroyed earlier).

âš ï¸ Ordering is difficult to reason about
because interceptors recursively create new sequences in arbitrary order.

âš ï¸ Hard to extend safely
as you add more roguelike content, recursion & stale state interactions get worse.

ğŸŸ© New Architecture: Listener Queue Model (target engine)

Model:

InitialEffects â†’ Queue â†’ 
  for each effect:
      run BEFORE listeners (priority-ordered)  
      APPLY effect (update state immediately)  
      run AFTER listeners (priority-ordered)  
      enqueue new effects  

Core properties

ğŸ”„ State updates incrementally after each effect.

ğŸ“¬ Listeners are generic event observers (not recursive interceptors).

ğŸ§¾ EffectQueue is linear, not recursive.

â± Complexity is near-linear, not exponential.

ğŸ§  Listeners decide if the effect matters (filter by position, actor, tags, etc.).

ğŸ›¡ï¸ High-priority listeners can modify/cancel effects before they apply.

ğŸ”¥ After-effect listeners can add new effects for chain reactions.

Listeners have only 2 hooks

onBeforeEffect(ctx, effect)
â†’ modify, replace, or cancel (effect = null)

onAfterEffect(ctx, effect)
â†’ produce new effects to enqueue

Everything else is expressed in terms of these two generic hooks.

Fixes all the old weaknesses

âœ” Live state, no stale references
Every listener sees the board exactly as it is right now.

âœ” Chain reactions are clean & predictable
No recursion, no exponential growth.

âœ” Protector-style logic works naturally
â€œCancel damage to an adjacent ally BEFORE it applies.â€

âœ” Invalid events mostly never happen
Since listeners see updated state in real time.

âœ” Content is easier to author
Listeners are simpler than recursive interceptors.

ğŸŸ¦ Conceptual Shift (in 3 lines)
Old: â€œEvents mutate at the end. Interceptors rewrite future events using a frozen world.â€
New: â€œEffects mutate immediately. Listeners observe/modify effects in real-time as the world changes.â€
ğŸŸ¨ What Stayed the Same

Still an event-based architecture

Still fully extensible

Still power-up friendly

Still rule-agnostic

Still supports decorators & tiles

Still deterministic & undoable (immutable state snapshots)

ğŸŸ¦ What Improved Dramatically

Correctness (no stale state)

Predictability (linear queue)

Performance (no recursive explosion)

Moddability (generic hooks)

Ability design (protector-style interactions now natural)

Debugging (effect log makes sense)

AI friendliness (clean incremental state transitions)

ğŸŸ© In One Sentence

We are replacing the recursive, frozen-state interceptor chain with a linear, live-state listener queue, where abilities observe and modify effects before and after each state-changing action, producing clean, incremental, predictable simulation.